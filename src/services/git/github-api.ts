import { Octokit } from '@octokit/rest';
import { config } from '../../config/index.js';
import { logger } from '../../utils/logger.js';
import { GitHubPRResult } from '../../types/index.js';

/**
 * GitHub API service for pull request operations
 *
 * Uses GitHub REST API (via Octokit) to:
 * - Create pull requests
 * - Add labels, reviewers, assignees
 * - Comment on PRs
 */
export class GitHubAPIService {
  private octokit: Octokit;
  private owner: string;
  private repo: string;

  constructor() {
    this.octokit = new Octokit({
      auth: config.github.token,
    });

    // Parse owner and repo from URL
    // Example: https://github.com/owner/repo.git -> owner=owner, repo=repo
    const match = config.github.targetRepoUrl.match(/github\.com[\/:]([^\/]+)\/([^\/\.]+)/);
    if (!match) {
      throw new Error(
        `Invalid GitHub URL format: ${config.github.targetRepoUrl}. Expected https://github.com/owner/repo.git`
      );
    }

    this.owner = match[1];
    this.repo = match[2];

    logger.debug('GitHub API initialized', {
      owner: this.owner,
      repo: this.repo,
    });
  }

  /**
   * Create a pull request
   *
   * @param branchName - The feature branch to merge
   * @param title - PR title
   * @param body - PR description (markdown supported)
   * @param baseBranch - Branch to merge into (default: main)
   */
  async createPullRequest(
    branchName: string,
    title: string,
    body: string,
    baseBranch?: string
  ): Promise<GitHubPRResult> {
    try {
      logger.info('üìù Creating pull request', {
        owner: this.owner,
        repo: this.repo,
        head: branchName,
        base: baseBranch || config.github.baseBranch,
      });

      const response = await this.octokit.pulls.create({
        owner: this.owner,
        repo: this.repo,
        title,
        body,
        head: branchName,
        base: baseBranch || config.github.baseBranch,
      });

      const prNumber = response.data.number;
      const prUrl = response.data.html_url;

      logger.success('Pull request created', {
        prNumber,
        prUrl,
      });

      return {
        success: true,
        prNumber,
        prUrl,
      };
    } catch (error: any) {
      // Handle common errors
      if (error.status === 422) {
        // Validation failed - might be duplicate PR
        const message = error.response?.data?.errors?.[0]?.message || error.message;
        logger.error('Failed to create PR - validation error', { message });
        return {
          success: false,
          error: `GitHub validation error: ${message}`,
        };
      }

      logger.error('Failed to create pull request', {
        error: error instanceof Error ? error.message : String(error),
        status: error.status,
      });

      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Format a PR description
   */
  formatPRDescription(analysis: string, solution: string, filesChanged: string[]): string {
    // Determine which components are affected based on file paths
    const hasBackend = filesChanged.some(f =>
      f.includes('apps/backend/') || f.endsWith('.rb') || f.includes('backend/')
    );
    const hasFrontend = filesChanged.some(f =>
      f.includes('apps/frontend/') || f.endsWith('.tsx') || f.endsWith('.ts') || f.includes('frontend/')
    );
    const hasInfra = filesChanged.some(f =>
      f.includes('.md') || f.includes('config') || f.includes('.yml') || f.includes('.yaml')
    );

    return `## Summary
${solution}

## Component
- [${hasBackend ? 'x' : ' '}] Backend (Rails)
- [${hasFrontend ? 'x' : ' '}] Frontend (Next.js)
- [${hasInfra ? 'x' : ' '}] Infrastructure/Docs/Config

---

## How to Test
1. Review the code changes in the Files tab
2. Pull the branch locally and test the affected functionality
3. Verify the fix addresses the reported issue
4. Check for any unintended side effects

**Analysis from Claude:**
${analysis}

---

## Checklist
- [x] Tests pass locally
- [ ] Tested manually
- [ ] QA approved (if user-facing)

## Notes
**Files Changed (${filesChanged.length}):**
${filesChanged.map((file) => `- \`${file}\``).join('\n')}

---
ü§ñ *This PR was automatically generated by [Claude AutoFix Bot](https://github.com/MattKilmer/claude-autofix-bot)*
*Co-authored-by: Claude <noreply@anthropic.com>*`;
  }

  /**
   * Format a PR title following conventional commit format
   * Format: type: [scope] description
   */
  formatPRTitle(branchType: string, description: string, filesChanged: string[]): string {
    // Determine scope based on file paths
    let scope = 'general';

    if (filesChanged.some(f => f.includes('api') || f.includes('controller'))) {
      scope = 'api';
    } else if (filesChanged.some(f => f.includes('checkout') || f.includes('payment'))) {
      scope = 'checkout';
    } else if (filesChanged.some(f => f.includes('auth'))) {
      scope = 'auth';
    } else if (filesChanged.some(f => f.includes('event'))) {
      scope = 'events';
    } else if (filesChanged.some(f => f.includes('frontend') || f.includes('.tsx'))) {
      scope = 'ui';
    } else if (filesChanged.some(f => f.includes('backend') || f.includes('.rb'))) {
      scope = 'backend';
    } else if (filesChanged.some(f => f.includes('README') || f.includes('.md'))) {
      scope = 'docs';
    }

    // Map branch type to conventional commit type
    const typeMap: Record<string, string> = {
      'fix': 'fix',
      'feat': 'feat',
      'feature': 'feat',
      'refactor': 'refactor',
      'docs': 'docs',
      'chore': 'chore',
      'test': 'test',
      'perf': 'perf',
    };

    const commitType = typeMap[branchType] || 'fix';

    // Truncate description to reasonable length
    const shortDesc = description.substring(0, 60).replace(/\s+$/, '');

    return `${commitType}: [${scope}] ${shortDesc}`;
  }

  /**
   * Add labels to a pull request
   */
  async addLabels(prNumber: number, labels: string[]): Promise<void> {
    try {
      await this.octokit.issues.addLabels({
        owner: this.owner,
        repo: this.repo,
        issue_number: prNumber,
        labels,
      });

      logger.debug('Labels added to PR', { prNumber, labels });
    } catch (error) {
      logger.warn('Failed to add labels', {
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  /**
   * Add a comment to a pull request
   */
  async addComment(prNumber: number, comment: string): Promise<void> {
    try {
      await this.octokit.issues.createComment({
        owner: this.owner,
        repo: this.repo,
        issue_number: prNumber,
        body: comment,
      });

      logger.debug('Comment added to PR', { prNumber });
    } catch (error) {
      logger.warn('Failed to add comment', {
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  /**
   * Request reviewers for a pull request
   */
  async requestReviewers(prNumber: number, reviewers: string[]): Promise<void> {
    try {
      await this.octokit.pulls.requestReviewers({
        owner: this.owner,
        repo: this.repo,
        pull_number: prNumber,
        reviewers,
      });

      logger.debug('Reviewers requested', { prNumber, reviewers });
    } catch (error) {
      logger.warn('Failed to request reviewers', {
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  /**
   * Get a preview deployment URL from PR comments
   *
   * Polls PR comments for preview URLs posted by deployment bots.
   * Supports: Vercel, Cloudflare Pages, and GitHub Actions bot comments.
   *
   * @param prNumber - The PR number to check
   * @param maxWaitMinutes - Maximum time to wait for the comment (default: 5 minutes)
   * @param repoOwner - Optional: override owner (for cross-repo lookups)
   * @param repoName - Optional: override repo (for cross-repo lookups)
   */
  async getPreviewUrlFromComments(
    prNumber: number,
    maxWaitMinutes: number = 5,
    repoOwner?: string,
    repoName?: string
  ): Promise<string | null> {
    const owner = repoOwner || this.owner;
    const repo = repoName || this.repo;
    const maxAttempts = (maxWaitMinutes * 60) / 15; // Check every 15 seconds
    let attempts = 0;

    logger.info('üîç Waiting for preview URL in PR comments', {
      owner,
      repo,
      prNumber,
      maxWait: `${maxWaitMinutes}min`,
    });

    // Give the deployment a few seconds to start
    await this.sleep(10000); // 10 seconds initial wait

    while (attempts < maxAttempts) {
      attempts++;

      try {
        const comments = await this.octokit.issues.listComments({
          owner,
          repo,
          issue_number: prNumber,
          per_page: 50,
        });

        for (const comment of comments.data) {
          // Only check bot comments
          if (comment.user?.type !== 'Bot') continue;

          const body = comment.body || '';

          // Cloudflare Pages: *.pages.dev URLs
          const cloudflareMatch = body.match(/https:\/\/[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+\.pages\.dev/);
          if (cloudflareMatch) {
            logger.success('Found Cloudflare Pages preview URL', {
              prNumber,
              previewUrl: cloudflareMatch[0],
              attempt: attempts,
            });
            return cloudflareMatch[0];
          }

          // Vercel: *.vercel.app URLs
          const vercelMatch = body.match(/https:\/\/[a-zA-Z0-9-]+(?:-[a-zA-Z0-9]+)*\.vercel\.app/);
          if (vercelMatch) {
            logger.success('Found Vercel preview URL', {
              prNumber,
              previewUrl: vercelMatch[0],
              attempt: attempts,
            });
            return vercelMatch[0];
          }

          // GitHub Actions "Web Preview Ready" comment with any URL
          if (body.includes('Web Preview Ready')) {
            const urlMatch = body.match(/https:\/\/[^\s|)]+\.pages\.dev[^\s|)]*/);
            if (urlMatch) {
              logger.success('Found web preview URL from GitHub Actions', {
                prNumber,
                previewUrl: urlMatch[0],
                attempt: attempts,
              });
              return urlMatch[0];
            }
          }
        }

        // Fallback: check GitHub deployment statuses
        try {
          const deployments = await this.octokit.repos.listDeployments({
            owner,
            repo,
            ref: `refs/pull/${prNumber}/head`,
            per_page: 10,
          });

          for (const deployment of deployments.data) {
            const statuses = await this.octokit.repos.listDeploymentStatuses({
              owner,
              repo,
              deployment_id: deployment.id,
              per_page: 5,
            });

            for (const status of statuses.data) {
              if (status.state === 'success' && status.environment_url) {
                logger.success('Found preview URL from deployment status', {
                  prNumber,
                  previewUrl: status.environment_url,
                  attempt: attempts,
                });
                return status.environment_url;
              }
            }
          }
        } catch {
          // Deployment status check is best-effort
        }

        logger.debug('Preview URL not found yet, waiting...', {
          attempt: attempts,
          commentsChecked: comments.data.length,
        });
      } catch (error) {
        logger.warn('Error fetching PR comments', {
          error: error instanceof Error ? error.message : String(error),
          attempt: attempts,
        });
      }

      // Wait before next attempt
      await this.sleep(15000); // 15 seconds
    }

    logger.warn('Preview URL not found in PR comments after max wait time', {
      prNumber,
      attempts,
    });
    return null;
  }

  /**
   * @deprecated Use getPreviewUrlFromComments instead
   */
  async getVercelPreviewUrlFromComments(
    prNumber: number,
    maxWaitMinutes: number = 5,
    repoOwner?: string,
    repoName?: string
  ): Promise<string | null> {
    return this.getPreviewUrlFromComments(prNumber, maxWaitMinutes, repoOwner, repoName);
  }

  /**
   * Utility sleep function
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * Get repository information
   */
  getRepoInfo() {
    return {
      owner: this.owner,
      repo: this.repo,
      fullName: `${this.owner}/${this.repo}`,
    };
  }

  /**
   * Get details of a specific pull request
   */
  async getPullRequest(prNumber: number, repoOwner?: string, repoName?: string): Promise<PRDetails | null> {
    try {
      const owner = repoOwner || this.owner;
      const repo = repoName || this.repo;

      logger.info('üìã Fetching PR details', { owner, repo, prNumber });

      const [prResponse, filesResponse, commentsResponse, reviewsResponse] = await Promise.all([
        this.octokit.pulls.get({
          owner,
          repo,
          pull_number: prNumber,
        }),
        this.octokit.pulls.listFiles({
          owner,
          repo,
          pull_number: prNumber,
          per_page: 100,
        }),
        this.octokit.issues.listComments({
          owner,
          repo,
          issue_number: prNumber,
          per_page: 50,
        }),
        this.octokit.pulls.listReviews({
          owner,
          repo,
          pull_number: prNumber,
          per_page: 50,
        }),
      ]);

      const pr = prResponse.data;
      const files = filesResponse.data;
      const comments = commentsResponse.data;
      const reviews = reviewsResponse.data;

      logger.success('PR details fetched', {
        prNumber,
        title: pr.title,
        filesCount: files.length,
        commentsCount: comments.length,
        reviewsCount: reviews.length,
      });

      return {
        number: pr.number,
        title: pr.title,
        body: pr.body || '',
        state: pr.state,
        author: pr.user?.login || 'unknown',
        branch: pr.head.ref,
        baseBranch: pr.base.ref,
        url: pr.html_url,
        createdAt: pr.created_at,
        updatedAt: pr.updated_at,
        files: files.map(f => ({
          filename: f.filename,
          status: f.status as 'added' | 'removed' | 'modified' | 'renamed',
          additions: f.additions,
          deletions: f.deletions,
          patch: f.patch || '',
        })),
        comments: comments.map(c => ({
          author: c.user?.login || 'unknown',
          body: c.body || '',
          createdAt: c.created_at,
        })),
        reviews: reviews.map(r => ({
          author: r.user?.login || 'unknown',
          state: r.state,
          body: r.body || '',
          submittedAt: r.submitted_at || '',
        })),
      };
    } catch (error: any) {
      logger.error('Failed to fetch PR details', {
        prNumber,
        error: error instanceof Error ? error.message : String(error),
        status: error.status,
      });

      if (error.status === 404) {
        logger.warn('PR not found', { prNumber });
        return null;
      }

      return null;
    }
  }

  /**
   * Parse a GitHub PR URL or reference to extract owner, repo, and PR number
   * Handles formats like:
   * - https://github.com/owner/repo/pull/123
   * - owner/repo#123
   * - #123 (uses default repo)
   */
  static parsePRReference(text: string, defaultOwner?: string, defaultRepo?: string): PRReference | null {
    // Match full GitHub URL: https://github.com/owner/repo/pull/123
    const urlMatch = text.match(/github\.com\/([^\/]+)\/([^\/]+)\/pull\/(\d+)/);
    if (urlMatch) {
      return {
        owner: urlMatch[1],
        repo: urlMatch[2],
        prNumber: parseInt(urlMatch[3], 10),
      };
    }

    // Match owner/repo#123 format
    const repoRefMatch = text.match(/([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_-]+)#(\d+)/);
    if (repoRefMatch) {
      return {
        owner: repoRefMatch[1],
        repo: repoRefMatch[2],
        prNumber: parseInt(repoRefMatch[3], 10),
      };
    }

    // Match simple #123 format (uses default repo)
    const simpleMatch = text.match(/#(\d+)(?:\s|$|[.,!?])/);
    if (simpleMatch && defaultOwner && defaultRepo) {
      return {
        owner: defaultOwner,
        repo: defaultRepo,
        prNumber: parseInt(simpleMatch[1], 10),
      };
    }

    return null;
  }

  /**
   * Extract all PR references from a text message
   */
  static extractPRReferences(text: string, defaultOwner?: string, defaultRepo?: string): PRReference[] {
    const references: PRReference[] = [];
    const seen = new Set<string>();

    // Find all GitHub URLs
    const urlMatches = text.matchAll(/github\.com\/([^\/]+)\/([^\/]+)\/pull\/(\d+)/g);
    for (const match of urlMatches) {
      const key = `${match[1]}/${match[2]}#${match[3]}`;
      if (!seen.has(key)) {
        seen.add(key);
        references.push({
          owner: match[1],
          repo: match[2],
          prNumber: parseInt(match[3], 10),
        });
      }
    }

    // Find all owner/repo#123 references
    const repoRefMatches = text.matchAll(/([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_-]+)#(\d+)/g);
    for (const match of repoRefMatches) {
      const key = `${match[1]}/${match[2]}#${match[3]}`;
      if (!seen.has(key)) {
        seen.add(key);
        references.push({
          owner: match[1],
          repo: match[2],
          prNumber: parseInt(match[3], 10),
        });
      }
    }

    // Find simple #123 references (only if default repo is specified)
    if (defaultOwner && defaultRepo) {
      const simpleMatches = text.matchAll(/(^|[^\/])#(\d+)(?:\s|$|[.,!?])/g);
      for (const match of simpleMatches) {
        const key = `${defaultOwner}/${defaultRepo}#${match[2]}`;
        if (!seen.has(key)) {
          seen.add(key);
          references.push({
            owner: defaultOwner,
            repo: defaultRepo,
            prNumber: parseInt(match[2], 10),
          });
        }
      }
    }

    return references;
  }
}

// ============================================
// PR DETAIL TYPES
// ============================================

export interface PRReference {
  owner: string;
  repo: string;
  prNumber: number;
}

export interface PRFileChange {
  filename: string;
  status: 'added' | 'removed' | 'modified' | 'renamed';
  additions: number;
  deletions: number;
  patch: string;
}

export interface PRComment {
  author: string;
  body: string;
  createdAt: string;
}

export interface PRReview {
  author: string;
  state: string;
  body: string;
  submittedAt: string;
}

export interface PRDetails {
  number: number;
  title: string;
  body: string;
  state: string;
  author: string;
  branch: string;
  baseBranch: string;
  url: string;
  createdAt: string;
  updatedAt: string;
  files: PRFileChange[];
  comments: PRComment[];
  reviews: PRReview[];
}

// Lazy singleton - only initialize when needed and config is valid
let _githubAPIService: GitHubAPIService | null = null;

export function getGitHubAPIService(): GitHubAPIService {
  if (!_githubAPIService) {
    _githubAPIService = new GitHubAPIService();
  }
  return _githubAPIService;
}

// Export getter for backwards compatibility
// This is lazily initialized on first access
export const githubAPIService = new Proxy({} as GitHubAPIService, {
  get(_target, prop) {
    return getGitHubAPIService()[prop as keyof GitHubAPIService];
  }
});
